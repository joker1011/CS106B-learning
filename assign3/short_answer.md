### 💡Q1. 在调试器中查看调用栈，什么可以表明正在调试的程序使用了递归？

```
调用栈内出现了相同位置的,重复的同名函数
```
### 💡Q2. 从最外层减去最内层的数字，可以得到调用栈最大的栈帧数。你的系统调用栈中有多少个栈帧呢？
 
```
10000-1=9999个
```
### 💡Q3. 描述无限递归的症状与无限循环的症状有何不同。　
```
无限循环－－循环内部变动了循环终止判断参数，使循环始终不能达到终止条件
无限递归－－Base Case的条件始终无法满足，递归无法实现回代
```

### 💡Q4. base 和 exp 导致测试失败的是什么情况？
```
１.情况１
base = -0   exp = -10 
myPower(0, -5) = 0d   pow(0, -5) = infd
当base为0时pow函数能正确地返回infinity错误，而myPower不能

2.情况2
当Base为负数，且exp的绝对值为偶数时会出现正负号问题
```
### 💡Q5. 在现有的五种情况下，是否有一些是重叠或多余的？你认为哪些是绝对必要的？有哪些 case 是你不确定的吗？
```c++
多余：
else if (base < 0) {  // handle negative base
        return -myPower(-base, exp);
经过上面的判断，可以确定当前的指数一定大于0.而对于负数的正次幂，没必要再设立一个判断语句将基底改成正值
如果单独加了这个判断，当指数为偶数时结果本应是正数，但这里强行加了负号导致了正负号差异．

必要：
    if (exp == 0) {         // handle zero exp
        return 1;
    }  else if (exp < 0) {   // handle negative exp
        return 1.0 / myPower(base, -exp);
    }  else {                // both base and exp are positive
        return base * myPower(base, exp - 1);

不确定：
else if (base == 0) { // handle zero base
        return 0;
似乎没必要专门设立一个判断
```

### 💡Q6. 将你的递归解决方案与下面的 checkBalance 迭代方法进行比较。你觉得哪个版本更容易阅读和理解？哪个版本更容易确认正确的行为？
```
递归的版本更好理解，更符合直观的逻辑，所以更不容易出错
```

### 💡Q7. 假设采用递归实现，粗略估计一下你的系统可以成功合并的最大序列。
```
不清楚
```

### 💡Q8. 如果试图递归合并一个大于最大值的序列，将会发生什么行为？
```
栈溢出程序终止．
```